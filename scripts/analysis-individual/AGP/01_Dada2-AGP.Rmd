---
title: "Dada2_AGP2021"
params:
  date: "!r Sys.Date()"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
---

```{r, include=FALSE}
knitr::opts_chunk$set(fig.width = 3.5, fig.height = 3, warning=FALSE, message=FALSE,
                      root.dir = "~/Projects/MetaIBS/scripts/analysis-individual/AGP/")
```


# 1. IMPORT

```{r library-import}
library(dada2)
packageVersion("dada2") # check dada2 version

library(Biostrings)
library(ShortRead)
library(seqTools) # per base sequence content
library(phyloseq)
library(ggplot2)
library(data.table)
library(plyr)
library(dplyr)
library(qckitfastq) # per base sequence content
library(stringr)

# ROOT DIRECTORY (to modify on your computer)
path.root <- "~/Projects/MetaIBS"
path.agp  <- file.path(path.root, "scripts/analysis-individual/AGP")
path.data <- file.path(path.root, "data/preprocessing/analysis-individual/AGP")
```


```{r html-import, echo = FALSE}
#_____________________________________________________________________
#____________ THIS IS ONLY FOR (quicker) HTML OUTPUT _________________
#_____________________________________________________________________

raw_stats     <- readRDS(file.path(path.data, "01_Dada2-AGP/raw_stats.rds")) # seq depth
out2          <- readRDS(file.path(path.data, "01_Dada2-AGP/out2.rds")) # out process
filt2_samples <- sort(list.files(file.path(path.data, "filtered_fastq"), pattern=".fastq.gz", full.names = TRUE)) # quality profiles
err           <- readRDS(file.path(path.data, "01_Dada2-AGP/err.rds")) # error rates
seq_infered   <- readRDS(file.path(path.data, "01_Dada2-AGP/seq_infered.rds")) # inferred ASVs
taxa          <- readRDS(file.path(path.data, "01_Dada2-AGP/taxa_agp_with_bloom.rds")) # taxa
physeq        <- readRDS(file.path(path.data, "01_Dada2-AGP/physeq_agp_with_bloom.rds")) # phyloseq object
```




********************
# 2. QUALITY CHECK
********************

First, we import the fastq files containing the raw reads. The samples were downloaded from the SRA database with the accession number PRJEB11419. IBS and healthy samples were selected out of the thousands of samples as described in [00_Metadata-AGP.R](00_Metadata-AGP.R).

```{r quality-check, echo=TRUE}
# Save the path to the directory containing the fastq zipped files
path.fastq <- file.path(path.agp, "download-AGP-samples/")
# list.files(path) # check we are in the right directory

# fastq filenames have format: SAMPLENAME.fastq.gz
# Saves the whole directory path to each file name
FNs <- sort(list.files(path.fastq, pattern=".fastq.gz", full.names = TRUE))
show(FNs[1:5])

# Extract sample names, assuming filenames have format: SAMPLENAME.fastq
sample.names <- sapply(strsplit(basename(FNs), "_"), `[`, 1)
show(sample.names[1:5]) # saves only the file name (without the path)

# Look at quality of all files
for (i in 1:4){ # 1:length(FNs)
  show(plotQualityProfile(FNs[i]))
}

# Look at nb of reads per sample
# raw_stats <- data.frame('sample' = sample.names,
#                         'reads' = fastqq(FNs)@nReads)
# min(raw_stats$reads)
# max(raw_stats$reads)
# mean(raw_stats$reads)
# hist(log10(raw_stats$reads))
```

We will have a quick peak at the per base sequence content of the reads in some samples, to make sure there is no anomaly (i.e. all reads having the same sequence).

```{r per-base-seq-content, fig.width = 6, fig.height = 3}
# Look at per base sequence content
fseq <- seqTools::fastqq(FNs[4])
rc <- read_content(fseq)
plot_read_content(rc) + labs(title = "Per base sequence content")
plot_read_content(rc) + xlim(0,50) + labs(title = "Per base sequence content")
```



########################
##  LOOK FOR PRIMERS  ##
########################

Now, we will look whether the reads still contain the primers.

```{r primer-check, eval = TRUE, message=FALSE}
# Import metadata, that contains the primer sequences
metadata <- read.csv(file.path(path.agp, "00_Metadata-AGP/SraRunTable.csv"))
table(metadata$pcr_primers..exp.)

# V4
FWD <- "GTGYCAGCMGCCGCGGTAA"  # 515F primer sequence
REV <- "GGACTACHVGGGTWTCTAAT" # 806R primer sequence

# Function that, from the primer sequence, will return all combinations possible (complement, reverse complement, ...)
allOrients <- function(primer) {
    # Create all orientations of the input sequence
    require(Biostrings)
    dna <- DNAString(primer)  # The Biostrings works w/ DNAString objects rather than character vectors
    orients <- c(Forward = dna, Complement = complement(dna), Reverse = reverse(dna), 
        RevComp = reverseComplement(dna))
    return(sapply(orients, toString))  # Convert back to character vector
}

# Get all combinations of the primer sequences
FWD.orients <- allOrients(FWD) # 515F
REV.orients <- allOrients(REV) # 806R
FWD.orients # sanity check
REV.orients

# Function that counts number of reads in which a sequence is found
primerHits <- function(primer, fn) {
    # Counts number of reads in which the primer is found
    nhits <- vcountPattern(primer, sread(readFastq(fn)), fixed = FALSE, max.mismatch = 2)
    return(sum(nhits > 0))
}

# Get a table to know how many times the 515F and 806R primers are found in the reads of each sample
for (i in 1:4){ # 1:length(FNs)
  cat("SAMPLE", sample.names[i], "with total number of", raw_stats[i,'reads'], "reads\n\n")
  x <-  rbind(ForwardPrimer = sapply(FWD.orients, primerHits, fn = FNs[[i]]), 
              ReversePrimer = sapply(REV.orients, primerHits, fn = FNs[[i]]))
  print(x)
  cat("\n____________________________________________\n\n")
}
```



#####################
## FILTER AND TRIM ##
#####################

### 1. Primer removal

The reads do not contain any primer. We will go forward directly with the quality filtering.


### 2. Quality filtering

Then, we perform a quality filtering of the reads.

```{r quality-filter, eval = FALSE, echo = TRUE}
# Place filtered files in a filtered/ subdirectory
filt2_samples <- file.path(path.data, "filtered_fastq", paste0(sample.names, "_filt.fastq.gz"))
# Assign names for the filtered fastq.gz files
names(filt2_samples) <- sample.names

out2 <- filterAndTrim(fwd = FNs, filt = filt2_samples,
                      maxEE=3, # reads with more than 3 expected errors (sum(10e(-Q/10))) are discarded
                      truncQ=10, # Truncate reads at the first instance of a quality score less than or equal to truncQ.
                      minLen=150, # Discard reads shorter than 150 bp.
                      multithread=TRUE,
                      compress=TRUE,
                      verbose=TRUE)


# Update list of filtered files
FNs_filt <- sort(list.files(file.path(path.data, "filtered_fastq"), pattern=".fastq.gz", full.names = TRUE))
sample.names_filt <- sapply(strsplit(basename(FNs_filt), "_"), `[`, 1)
names(FNs_filt) <- sample.names_filt

```


About ~35 samples had a large number of reads but none of them passed the quality filter. Let's inspect quickly the quality profile of some of them.

```{r}
for (i in 195:234){ # printing 2 samples before & after the "abnormal samples", that actually passed the quality filter (as comparison)
  show(plotQualityProfile(FNs[i]))
}
```

The quality profile of these discarded samples show some abnormalities, and reads were also shorter than 150bp. It is not surprising none of the reads passed the quality filtering.



#######################
## LEARN ERROR RATES ##
#######################

Now we will build the parametric error model, to be able to infer amplicon sequence variants (ASVs) later on.

```{r error-rate-estimate, eval = FALSE}
set.seed(123)
err <- learnErrors(FNs_filt, multithread=TRUE, randomize=TRUE, verbose = 1)
```

The error rates for each possible transition (A→C, A→G, …) are shown. Points are the observed error rates for each consensus quality score. The black line shows the estimated error rates after convergence of the machine-learning algorithm. The red line shows the error rates expected under the nominal definition of the Q-score. Here the estimated error rates (black line) are a good fit to the observed rates (points), and the error rates drop with increased quality as expected.

```{r plot-errors, fig.height=5, fig.width=5}
plotErrors(err, nominalQ = TRUE)
```



##############################
## CONSTRUCT SEQUENCE TABLE ##
##############################

### 1. Infer sample composition

The _dada()_ algorithm infers sequence variants based on estimated errors (previous step). Firstly, we de-replicate the reads in each sample, to reduce the computation time.
De-replication is a common step in almost all modern ASV inference (or OTU picking) pipelines, but a unique feature of derepFastq is that it maintains a summary of the quality information for each dereplicated sequence in $quals.

```{r infer-sample-composition, eval = FALSE}
# Prepare empty vector for the infered sequences
seq_infered <- vector("list", length(sample.names_filt))
names(seq_infered) <- sample.names_filt # names of each row will be the sample names

# Iterate through the 1242 samples
for(sampl in sample.names_filt) {
  cat("Processing:", sampl, "\n") # print which sample is being processed
  derep <- derepFastq(FNs_filt[[sampl]]) # dereplicate the reads in the sample
  seq_infered[[sampl]] <- dada(derep, err=err, multithread=TRUE) # default parameters
}
```

```{r}
# Inspect the infered sequence variants from sample 1:5
for (i in 1:5){
  print(seq_infered[[i]])
  print("________________")
}
```


### 2. Construct ASV table

We can now construct an amplicon sequence variant table (ASV) table, a higher-resolution version of the OTU table produced by traditional methods.

```{r build-seq-table, fig.height=3, fig.width=4}
# Make sequence table from the infered sequence variants
seqtable <- makeSequenceTable(seq_infered)

# We should have 1242 samples (1242 rows)
dim(seqtable)

# Inspect distribution of sequence lengths
hist(nchar(getSequences(seqtable)), breaks = 100, xlab = "ASV length", ylab = "Number of ASVs", main="")
```


### 3. Remove chimeras

The core dada method corrects substitution and indel errors, but chimeras remain. Fortunately, the accuracy of sequence variants after denoising makes identifying chimeric ASVs simpler than when dealing with fuzzy OTUs. Chimeric sequences are identified if they can be exactly reconstructed by combining a left-segment and a right-segment from two more abundant “parent” sequences.

```{r remove-chimeras}
seqtable.nochim <- removeBimeraDenovo(seqtable, method="consensus", multithread=TRUE, verbose=TRUE)

# Check how many sequence variants we have after removing chimeras
dim(seqtable.nochim)

# Check how many reads we have after removing chimeras (we should keep the vast majority of the reads, like > 80%)
sum(seqtable.nochim)/sum(seqtable)
```




##########################################
## LOOK AT READS COUNT THROUGH PIPELINE ##
##########################################

Sanity check before assigning taxonomy.

```{r reads-filtered-sanity-check}
# Function that counts nb of reads
getN <- function(x) sum(getUniques(x))

# Table that will count number of reads for each process of interest (input reads, filtered reads, denoised reads, non chimera reads)
rownames(out2) <- sapply(strsplit(rownames(out2), "_"), `[`, 1)
track <- out2 %>%
  as.data.frame() %>%
  mutate(Run=rownames(out2)) %>%
  rename("input"="reads.in",
         "quality-filt"="reads.out") %>%
  left_join(sapply(seq_infered, getN) %>%
              as.data.frame %>% 
              rename(denoised=".") %>%
              mutate(Run=names(sapply(seq_infered, getN))),
            by="Run") %>%
  left_join(rowSums(seqtable.nochim) %>%
              as.data.frame %>%
              rename(nonchim=".") %>%
              mutate(Run=rownames(seqtable.nochim)),
            by="Run") %>%
  relocate(Run) %>%
  mutate("%input->output"=as.integer(nonchim*100/input))

# Show final table: for each row/sample, we have shown the initial number of reads, filtered reads, denoised reads, and non chimera reads
track
```

```{r seqdepth, echo=FALSE, eval=FALSE, include=FALSE}
# Save nb of reads per sample before / after dada2 pipeline
nb.reads <- as.data.frame(rowSums(seqtable.nochim)) %>%
  rename("after"="rowSums(seqtable.nochim)") %>%
  mutate("Run"=names(rowSums(seqtable.nochim))) %>%
  right_join(raw_stats %>% rename(Run=sample, before=reads),
             by="Run") %>%
  relocate(before) %>%
  relocate(Run) %>%
  mutate(after = nafill(after, fill=0),
         "dataset" = "AGP")

saveRDS(nb.reads, file.path(path.root, "data/preprocessing/dada2-filt/nbreads_agp.rds"))
```


#####################
## ASSIGN TAXONOMY ##
#####################

Extensions: The dada2 package also implements a method to make species level assignments based on exact matching between ASVs and sequenced reference strains. Recent analysis suggests that exact matching (or 100% identity) is the only appropriate way to assign species to 16S gene fragments. Currently, species-assignment training fastas are available for the Silva and RDP 16S databases (you can download them from the DADA2 website).

```{r assign-taxonomy, eval = FALSE}
# Assign taxonomy (with silva v138)
taxa <- assignTaxonomy(seqtable.nochim, file.path(path.root, "data/preprocessing/silva-taxonomic-ref/silva_nr_v138_train_set.fa.gz"),
                       tryRC = TRUE, # try reverse complement of the sequences
                       multithread=TRUE, verbose = TRUE)

# Add species assignment
taxa <- addSpecies(taxa, file.path(path.root, "data/preprocessing/silva-taxonomic-ref/silva_species_assignment_v138.fa.gz"))
```

```{r taxa-sanity-check}
# Check how the taxonomy table looks like
taxa.print <- taxa
rownames(taxa.print) <- NULL # Removing sequence rownames for display only
head(taxa.print)

table(taxa.print[,1]) # Show the different kingdoms

table(taxa.print[,2]) # Show the different phyla
table(is.na(taxa.print[,2])) # is there any NA phyla?
```


########################
## LAST PREPROCESSING ##
########################

We will remove any sample with less than 500 reads from further analysis, and also any ASVs with unassigned phyla.

### 1. Create phyloseq object
The preprocessing will be easier to do with ASV, taxonomic and metadata tables combined in a phyloseq object.

```{r phyloseq-preprocess, echo=TRUE, eval=FALSE}
#_________________________
# Import metadata
metadata <- read.csv(file.path(path.agp, "00_Metadata-AGP/Metadata-AGP.csv"))

# Keep relevant covariates
sampledf <- metadata %>%
  select(-"pcr_primers..exp.") %>%
  select(-"X")
rownames(sampledf) <- sampledf$Run

sampledf[sampledf$host_disease == "Healthy", "host_subtype"] <- "HC"
sampledf[sampledf$host_disease == "IBS", "host_subtype"] <- "IBS-unspecified"

sampledf$Collection <- "1st" # only 1 time point per individual
sampledf$sample_type <- "stool"
sampledf$author <- "AGP"
sampledf$sequencing_tech <- "Illumina single-end"
sampledf$variable_region <- "V4"

#_________________________
# Create phyloseq object
physeq <- phyloseq(otu_table(seqtable.nochim, taxa_are_rows=FALSE), # by default, in otu_table the sequence variants are in rows
                   sample_data(sampledf), 
                   tax_table(taxa))

# Remove taxa that are eukaryota, or have unassigned Phyla
physeq <- subset_taxa(physeq, Kingdom != "Eukaryota")
physeq <- subset_taxa(physeq, !is.na(Phylum))
# Remove samples with less than 500 reads
physeq <- prune_samples(sample_sums(physeq)>=500, physeq)
# Some taxa might have been present only in these low-count samples, so we will make sure to remove taxa that are absent in all samples
physeq <- prune_taxa(taxa_sums(physeq)>0, physeq)
```



### 2. Quick peek at data analysis

```{r plot, fig.width = 10}
# Absolute abundance
# plot_bar(physeq, fill = "Phylum")+ facet_wrap("host_disease", scales="free") + theme(axis.text.x = element_blank()) # long to compute

# Relative abundance for Phylum
phylum.table <- physeq %>%
  tax_glom(taxrank = "Phylum") %>%                     # agglomerate at phylum level
  transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
  psmelt()                                             # Melt to long format

ggplot(phylum.table, aes(x = reorder(Sample, Sample, function(x) mean(phylum.table[Sample == x & Phylum == 'Bacteroidota', 'Abundance'])),
                         y = Abundance, fill = Phylum))+
  facet_wrap(~ host_disease, scales = "free") + # scales = "free" removes empty lines
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_blank(),
        legend.text = element_text(size=6),
        legend.key.size = unit(0.3, 'cm'))+
  labs(x = "Samples", y = "Relative abundance")

```


### 3. Remove bloom sequences

Looking at it more closely, there is a high proportion of Proteobacteria compared to other datasets. Considering that fecal samples were shipped from the participants' home at room temperature, there is evidence that some bacteria grow at room temperature, which would bias the microbial composition (https://journals.asm.org/doi/10.1128/mSystems.00199-16#B5). Authors from the AGP removed a selection of **bloom sequences** that were shared on their [github repository][1] in a FASTA file.

[1]: https://github.com/knightlab-analyses/bloom-analyses

```{r bloom-sequences, fig.width = 10, fig.height = 5}
# Import bloom sequences
bloom <- readDNAStringSet(file.path(path.data, "newbloom.all.fna"))


# Identify ASVs to keep (ones that are not bloom sequences)
# note: trim ASVs to 150bp as bloom sequences are 150bp (a few ASVs are 151bp)

allASV <- taxa_names(physeq)
names(allASV) <- paste0("ASV", 1:length(allASV))

# 1 - Identify ASVs to keep (ones that are not bloom sequences) in the ASVs that are 150bp
shortASV <- allASV[nchar(allASV) == 150]
shortASV_tokeep <- names( shortASV[!(shortASV %in% bloom)] ) # 8,903

# 2 - Identify ASVs to keep (ones that are not bloom sequences) in the ASVs that are 151bp
longASV <- allASV[nchar(allASV) == 151]
longASV_trim1 <- subseq(longASV, start=1, width=150) # range 1 - 150
longASV_trim2 <- subseq(longASV, start=2, width=150) # range 2 - 151

longASV_tokeep1 <- names( longASV_trim1[!(longASV_trim1 %in% bloom)] ) # bloom seqs in 1 - 150 range
longASV_tokeep2 <- names( longASV_trim2[!(longASV_trim2 %in% bloom)] ) # bloom seqs in 2 - 151 range

longASV_tokeep <- intersect(longASV_tokeep1, longASV_tokeep2)

# 3 - Combine and get the **sequences** to keep (not the names)
ASV_to_keep <- allASV[c(shortASV_tokeep, longASV_tokeep)]

# Check taxonomic classification of these bloom sequences
tax_table(physeq) %>%
  as.data.frame %>%
  tibble::rownames_to_column(var="ASV") %>%
  filter(!ASV %in% ASV_to_keep) %>%
  group_by(Phylum) %>%
  dplyr::summarise(n=n())

# Remove unwanted taxa (bloom)
physeq.filt <- prune_taxa(ASV_to_keep, physeq)
physeq.filt <- prune_samples(sample_sums(physeq.filt)>=500, physeq.filt) # 16,767 ASVs and 1,183 samples
physeq.filt <- prune_taxa(taxa_sums(physeq.filt)>0, physeq.filt) # remove taxa absent in all samples

phylum.table.filt <- physeq.filt %>%
  tax_glom(taxrank = "Phylum") %>%                     # agglomerate at phylum level
  transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
  psmelt()                                             # Melt to long format


# PLOT TO COMPARE
a <- ggplot(phylum.table, aes(x = host_disease,
                              y = Abundance, fill = Phylum))+
  geom_bar(stat = "identity", position="fill") +
  theme_bw()+
  theme(legend.position="none")+
  labs(x = "", y = "Relative abundance", title = "Original data")

b <- ggplot(phylum.table.filt, aes(x = host_disease,
                                   y = Abundance, fill = Phylum))+
  geom_bar(stat = "identity", position="fill") +
  # theme(axis.text.x = element_blank())+
  labs(x = "", y = "Relative abundance", title = "Bloom sequences removed")+
  theme_bw()

gridExtra::grid.arrange(a, b, ncol=2, widths=c(0.3,0.7))
```


### 4. Save to disk

```{r save, eval=FALSE}
# Save to disk (for quicker html output)
saveRDS(raw_stats,   file.path(path.data, "01_Dada2-AGP/raw_stats.rds"))
saveRDS(out2,        file.path(path.data, "01_Dada2-AGP/out2.rds"))
saveRDS(err,         file.path(path.data, "01_Dada2-AGP/err.rds"))
saveRDS(seq_infered, file.path(path.data, "01_Dada2-AGP/seq_infered.rds"))

# Taxa & Phyloseq object (before removing bloom sequences)
saveRDS(taxa,   file.path(path.data, "01_Dada2-AGP/taxa_agp_with_bloom.rds"))
saveRDS(physeq, file.path(path.data, "01_Dada2-AGP/physeq_agp_with_bloom.rds")) # phyloseq object

# Taxa & Phyloseq object (after removing bloom sequences => final)
saveRDS(tax_table(physeq.filt), file.path(path.root, "data/preprocessing/analysis-individual/CLUSTER/taxonomy/output/taxa_agp.rds"))
saveRDS(physeq.filt, file.path(path.root, "data/preprocessing/analysis-individual/CLUSTER/phylotree/input/physeq_agp.rds"))
```