---
title: "Dada2_Nagel2016"
params:
  date: "!r Sys.Date()"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
---

```{r, include=FALSE}
knitr::opts_chunk$set(fig.width = 3.5, fig.height = 3, warning=FALSE, message=FALSE,
                      root.dir = "~/Projects/MetaIBS/")
```




***********
# 1. IMPORT
***********

```{r library-import}
library(dada2)
packageVersion("dada2") # check dada2 version

library(Biostrings)
library(ShortRead)
library(seqTools) # per base sequence content
library(phyloseq)
library(ggplot2)
library(data.table)
library(plyr)
library(dplyr)
library(qckitfastq) # per base sequence content
library(stringr)

# ROOT DIRECTORY (to modify on your computer)
path.root <- "~/Projects/MetaIBS"
path.nagel <- file.path(path.root, "scripts/analysis-individual/Nagel-2016")
path.data  <- file.path(path.root, "data/preprocessing/analysis-individual/Nagel-2016")
```

```{r html-import, echo = FALSE}
#_____________________________________________________________________
#____________ THIS IS ONLY FOR (quicker) PDF/HTML OUTPUT __________________
#_____________________________________________________________________

raw_stats     <- readRDS(file.path(path.data, "01_Dada2-Nagel/raw_stats.rds")) # out process
out1          <- readRDS(file.path(path.data, "01_Dada2-Nagel/out1.rds")) # out process (primer removal)
out2          <- readRDS(file.path(path.data, "01_Dada2-Nagel/out2.rds")) # out process (QC)
trim_samples  <- sort(list.files(file.path(path, "original_trim"), pattern=".fastq.gz", full.names = TRUE)) # reads with length >50bp
filt1_samples <- sort(list.files(file.path(path, "filtered1"), pattern=".fastq.gz", full.names = TRUE)) # reads with primers removed
filt2_samples <- sort(list.files(file.path(path, "filtered2"), pattern=".fastq.gz", full.names = TRUE)) # quality-filtered reads
err           <- readRDS(file.path(path.data, "01_Dada2-Nagel/errorRates.rds")) # error rates
err_new       <- readRDS(file.path(path.data, "01_Dada2-Nagel/errorRates_modif.rds")) # error rates manually adjusted
seq_infered   <- readRDS(file.path(path.data, "01_Dada2-Nagel/seq_infered.rds")) # inferred ASVs
taxa          <- readRDS(file.path(path.data, "01_Dada2-Nagel/taxa_nagel.rds")) # taxa
physeq        <- readRDS(file.path(path.root, "data/preprocessing/analysis-individual/CLUSTER/PhyloTree/input/physeq_nagel.rds")) # phyloseq object without phylogenetic tree
```




******************
# 2. QUALITY CHECK
******************

### 2.1. Fastq quality profiles
First, we import the fastq files containing the raw reads. The samples were kindly shared by the author. 

```{r quality-check, echo=TRUE, results="hide", fig.height=3, fig.width=4}
# Save the path to the directory containing the fastq zipped files
path.fastq <- file.path(path.nagel, "download-Nagel-samples/")
# list.files(path.fastq) # check we are in the right directory

# fastq filenames have format: SAMPLENAME.fastq
# Saves the whole directory path to each file name
FNs <- sort(list.files(path.fastq, pattern=".fastq", full.names = TRUE))
show(FNs[1:5])

# Extract sample names, assuming filenames have format: SAMPLENAME.fastq
sample.names <- sapply(strsplit(basename(FNs), "_"), `[`, 1)
show(sample.names) # saves only the file name (without the path)

# After demultiplexing, sanity check of read length
seqlen.tab <- table(width(readFastq(FNs[1])))
seqleng <- as.integer(names(seqlen.tab))
counts <- as.integer(seqlen.tab)
plot(x=seqleng, y=log10(counts)) # some reads are of length 0 => need to remove them
```

Some reads are of length 0. To avoid having issues with looking at the quality profile of the samples, we will first remove all reads below 50bp.
```{r remove-short-reads, eval = FALSE}
# Place filtered reads in a original_trim/ subdirectory
trim_samples <- file.path(path.data, "original_trim", paste0(sample.names, "_trim.fastq.gz"))
names(trim_samples) <- sample.names # assign names

# Remove reads with less than 50bp
trim <- filterAndTrim(fwd = FNs, filt = trim_samples,
                     truncQ=0, # default truncQ is 2
                     minLen = 50, # Discard reads shorter than 50 bp.
                     compress=TRUE,
                     verbose=TRUE)
# ~ 90-97% sequences filtered
```

Now we can look at the quality profile of the samples.
```{r plot-quality}
# Look at quality of all files
for (i in 1:4){ # 1:length(trim_samples)
  show(plotQualityProfile(trim_samples[i]))
}

# Look at nb of reads per sample
# raw_stats <- data.frame('sample' = sample.names,
#                         'reads' = fastqq(trim_samples)@nReads)
# min(raw_stats$reads)
# max(raw_stats$reads)
# mean(raw_stats$reads)
```

We will have a quick peak at the per base sequence content of the reads in some samples, to make sure there is no anomaly.
```{r per-base-seq-content, fig.width = 6, fig.height = 3}
# Look at per base sequence content
fseq <- seqTools::fastqq(trim_samples[1])
rc <- read_content(fseq)
plot_read_content(rc) + labs(title = "Per base sequence content")
plot_read_content(rc) + xlim(0,50) + labs(title = "Per base sequence content")
```


### 2.2. Look for primers
Now, we will look whether the reads still contain the primers. Primer sequences are given in the methods section of the paper.

```{r primer-check, eval = TRUE, message=FALSE}
FWD <- "GTGCCAGCMGCCGCGGTAA"  # 515F primer sequence
REV <- "GGACTACHVGGGTWTCTAAT" # 806R primer sequence

# Function that, from the primer sequence, will return all combinations possible (complement, reverse complement, ...)
allOrients <- function(primer) {
    # Create all orientations of the input sequence
    require(Biostrings)
    dna <- DNAString(primer)  # The Biostrings works w/ DNAString objects rather than character vectors
    orients <- c(Forward = dna, Complement = complement(dna), Reverse = reverse(dna), 
        RevComp = reverseComplement(dna))
    return(sapply(orients, toString))
}

# Get all combinations of the primer sequences
FWD.orients <- allOrients(FWD) # 515F
REV.orients <- allOrients(REV) # 806R
FWD.orients # sanity check
REV.orients 

# Function that counts number of reads in which a sequence is found
primerHits <- function(primer, fn) {
    nhits <- vcountPattern(primer, sread(readFastq(fn)), fixed = FALSE, max.mismatch = 2)
    return(sum(nhits > 0))
}

# Look in all samples if we find the primers
for (i in 1:5){
  cat("SAMPLE", sample.names[i], "with total number of", raw_stats[i,'reads'], "reads\n\n")
  x <-  rbind(ForwardPrimer = sapply(FWD.orients, primerHits, fn = trim_samples[[i]]), 
              ReversePrimer = sapply(REV.orients, primerHits, fn = trim_samples[[i]]))
  print(x)
  cat("\n____________________________________________\n\n")
}
```




********************
# 3. FILTER AND TRIM
********************

### 3.1. Primer removal
The reads indeed contain both primers. We will keep only reads containing both primers, and trim the primers.

```{r primer-filter, eval = FALSE, echo = TRUE}
# KEEP READS WITH PRIMER AND REMOVE PRIMER
# Place filtered files in a filtered/ subdirectory
filt1_samples <- file.path(path.data, "filtered1", paste0(sample.names, "_filt.fastq.gz"))
# Assign names for the filtered fastq.gz files
names(filt1_samples) <- sample.names

# Filter first to take out primer
out1 <- removePrimers(fn = trim_samples, fout = filt1_samples,
                      primer.fwd = FWD.orients['Forward'],
                      primer.rev = REV.orients['RevComp'],
                      trim.fwd = TRUE,
                      trim.rev = TRUE,
                      orient = FALSE, # keep the reads in their original orientation
                      compress = TRUE, verbose = TRUE)
```

```{r primer-filter-check}
# Primer removal
out1[1:4,]

# Quality profile after primer removal
for (i in 1:4){
  show(plotQualityProfile(filt1_samples[i]))
}
```



### 3.2. Quality filtering
Then, we perform a quality filtering of the reads.

```{r filter-trim, eval = FALSE, echo = TRUE}
# Place filtered files in a filtered/ subdirectory
filt2_samples <- file.path(path, "filtered2", paste0(sample.names, "_filt.fastq.gz"))
# Assign names for the filtered fastq.gz files
names(filt2_samples) <- sample.names

# Filter
out2 <- filterAndTrim(fwd = filt1_samples, filt = filt2_samples,
                      maxEE=3, # reads with more than 3 expected errors (sum(10e(-Q/10))) are discarded
                      truncQ=10, # Truncate reads at the first instance of a quality score less than or equal to truncQ.
                      minLen = 150, # Discard reads shorter than 150 bp.
                      compress=TRUE,
                      multithread=TRUE,
                      verbose=TRUE)
```

Let's look at the output filtered fastq files as sanity check.
```{r quality-filter-check}
out2[1:4,] # show how many reads were filtered in each file

# Look at quality profile of filtered files
for (i in 1:4){
  show(plotQualityProfile(filt2_samples[i]))
}
```




************************
# 4. CONSTRUCT ASV TABLE
************************

### 4.1. Learn error rates
Now we will build the parametric error model, to be able to infer amplicon sequence variants (ASVs) later on.

```{r error-rate-estimate, eval = FALSE}
err <- learnErrors(filt2_samples, multithread=TRUE, randomize=TRUE, verbose = 1)
```

The error rates for each possible transition (A→C, A→G, …) are shown. Points are the observed error rates for each consensus quality score. The black line shows the estimated error rates after convergence of the machine-learning algorithm. The red line shows the error rates expected under the nominal definition of the Q-score.

```{r plot-errors, fig.height=5, fig.width=5}
plotErrors(err, nominalQ = TRUE)
```

As the error rate model doesn’t fit well the observations for high quality scores, we will manually modify it to better fit.
```{r adjust-errors, eval = FALSE}
# Modify error rate model
err_new <- err

# G2T
err_new$err_out['G2T','35':'38'] <- 0.0016
err_new$err_out['G2T','38'] <- 0.0014
err_new$err_out['G2T','39'] <- 0.0013
err_new$err_out['G2T','40'] <- 0.00115
err_new$err_out['G2T','41'] <- 0.0010
err_new$err_out['G2T','42'] <- 0.00085
err_new$err_out['G2T','43'] <- 0.0007
err_new$err_out['G2T','44'] <- 0.00055
err_new$err_out['G2T','45'] <- 0.0004

# All the other transitions/transversions
err_new$err_out['A2C','35':'46'] <- 0.0008
err_new$err_out['A2G','38':'46'] <- 0.007
err_new$err_out['A2T','37':'46'] <- 0.002
err_new$err_out['C2A','37':'46'] <- 0.0008
err_new$err_out['C2G','39':'46'] <- 0.0025
err_new$err_out['C2T','38':'46'] <- 0.007
err_new$err_out['G2A','36':'46'] <- 0.0035
err_new$err_out['G2C','36':'46'] <- 0.0006
err_new$err_out['T2A','38':'46'] <- 0.0025
err_new$err_out['T2C','36':'46'] <- 0.0065
err_new$err_out['T2G','36':'46'] <- 0.0025
```

```{r plot-new-errors, fig.height=5, fig.width=5}
# Check modified error rate model
plotErrors(err_new, nominalQ = TRUE)
```


### 4.2. Infer sample composition
The _dada()_ algorithm infers sequence variants based on estimated errors (previous step). Firstly, we de-replicate the reads in each sample, to reduce the computation time.
De-replication is a common step in almost all modern ASV inference (or OTU picking) pipelines, but a unique feature of derepFastq is that it maintains a summary of the quality information for each dereplicated sequence in $quals.

```{r infer-sample-composition, eval = FALSE}
# Prepare empty vector for the infered sequences
seq_infered <- vector("list", length(sample.names))
names(seq_infered) <- sample.names # names of each row will be the sample names

# Iterate through the 30 samples
for(sampl in sample.names) {
  cat("Processing:", sampl, "\n")
  derep <- derepFastq(filt2_samples[[sampl]]) # dereplicate the reads in the sample
  seq_infered[[sampl]] <- dada(derep, err=err_new, multithread=TRUE, # default parameters
                               HOMOPOLYMER_GAP_PENALTY=-1, BAND_SIZE=32) # parameters for Ion Torrent recommended
}
```

```{r}
# Inspect the infered sequence variants from sample 1:5
for (i in 1:5){
  print(seq_infered[[i]])
  print("________________")
}
```


### 4.3. Construct ASV table
We can now construct an amplicon sequence variant table (ASV) table, a higher-resolution version of the OTU table produced by traditional methods.

```{r build-seq-table, fig.height=3, fig.width=4}
# Make sequence table from the infered sequence variants
seqtable <- makeSequenceTable(seq_infered)

# We should have 30 samples (30 rows)
dim(seqtable)

# Inspect distribution of sequence lengths
hist(nchar(getSequences(seqtable)), breaks = 100, xlab = "ASV length", ylab = "Number of ASVs", main="")
```


### 4.4. Remove chimeras
The core dada method corrects substitution and indel errors, but chimeras remain. Fortunately, the accuracy of sequence variants after denoising makes identifying chimeric ASVs simpler than when dealing with fuzzy OTUs. Chimeric sequences are identified if they can be exactly reconstructed by combining a left-segment and a right-segment from two more abundant “parent” sequences.

```{r remove-chimeras}
seqtable.nochim <- removeBimeraDenovo(seqtable, method="consensus", multithread=TRUE, verbose=TRUE)

# Check how many sequence variants we have after removing chimeras
dim(seqtable.nochim)

# Check how many reads we have after removing chimeras (we should keep the vast majority of the reads, like > 80%)
sum(seqtable.nochim)/sum(seqtable)
```




*****************************************
# 5. LOOK AT READS COUNT THROUGH PIPELINE
*****************************************

Sanity check before assigning taxonomy.

```{r reads-filtered-sanity-check}
# Function that counts nb of reads
getN <- function(x) sum(getUniques(x))

# Table that will count number of reads for each process of interest (input reads, filtered reads, denoised reads, non chimera reads)
track <- cbind(out1, out2[,2], sapply(seq_infered, getN), rowSums(seqtable.nochim),
               lapply(rowSums(seqtable.nochim)*100/out1[,1], as.integer))

# Assign column and row names
colnames(track) <- c("input", "primer-filt", "quality-filt", "denoised", "nonchim", "%input->output")
rownames(track) <- sample.names

# Show final table: for each row/sample, we have shown the initial number of reads, filtered reads, denoised reads, and non chimera reads
track
```

```{r seqdepth, echo=FALSE, eval=FALSE, include=FALSE}
# Save nb of reads per sample before / after dada2 pipeline
nb.reads <- data.frame("before" = raw_stats$reads,
                       "after" = rowSums(seqtable.nochim),
                       "dataset" = "Nagel")
# better alternative? choose!!
# nb.reads <- as.data.frame(rowSums(seqtable.nochim)) %>%
#   rename("after"="rowSums(seqtable.nochim)") %>%
#   mutate("Run"=names(rowSums(seqtable.nochim))) %>%
#   right_join(raw_stats %>% rename(Run=sample, before=reads),
#              by="Run") %>%
#   relocate(before) %>%
#   relocate(Run) %>%
#   mutate(after = nafill(after, fill=0),
#          "dataset" = "AGP")

saveRDS(nb.reads, file.path(path.root, "data/preprocessing/dada2-filt/nbreads_nagel.rds")
```




********************
# 6. TAXONOMIC TABLE
********************

Extensions: The dada2 package also implements a method to make species level assignments based on exact matching between ASVs and sequenced reference strains. Recent analysis suggests that exact matching (or 100% identity) is the only appropriate way to assign species to 16S gene fragments. Currently, species-assignment training fastas are available for the Silva and RDP 16S databases. To follow the optional species addition step, download the silva_species_assignment_v132.fa.gz file, and place it in the directory with the fastq files.

```{r assign-taxonomy-on-cluster, eval=FALSE, echo=FALSE, include=FALSE}
# In case you prefer to assign taxonomy on a computer cluster (in other words run this chunk on a computer cluster), you can export the ASV table
# saveRDS(seqtable.nochim, file.path(path.root, "data/preprocessing/analysis-individual/CLUSTER/taxonomy/input/seqtablenochim_nagel.rds"))

# then you can :
# 1. copy the "data/preprocessing/analysis-individual/CLUSTER/taxonomy/" directory to your cluster (where there is the input data & R scripts to assign taxonomy)
# 2. run the R scripts on the cluster (they will output the taxonomic tables in the "output/" subdirectory)
# 3. copy the "taxonomy/output/" subdirectory back to your personal computer
# 4. import the taxonomic table below (in that case you don't need to run the next code chunk "assign-taxonomy"):
# taxa <- readRDS(file.path(path.root, "data/preprocessing/analysis-individual/CLUSTER/taxonomy/output/taxa_nagel.rds"))
```

```{r assign-taxonomy, eval = FALSE}
path.silva <- file.path(path.root, "data/preprocessing/analysis-individual/CLUSTER/taxonomy/silva-taxonomic-ref")

# Assign taxonomy (with silva v138)
taxa <- assignTaxonomy(seqtable.nochim, file.path(path.silva, "silva_nr_v138_train_set.fa.gz"),
                       tryRC = TRUE, # try reverse complement of the sequences
                       multithread=TRUE, verbose = TRUE)

# Add species assignment
taxa <- addSpecies(taxa, file.path(path.silva, "silva_species_assignment_v138.fa.gz"))
```

```{r taxa-sanity-check}
# Check how the taxonomy table looks like
taxa.print <- taxa
rownames(taxa.print) <- NULL # Removing sequence rownames for display only
head(taxa.print)

table(taxa.print[,1]) # Show the different kingdoms (should be only bacteria)
table(taxa.print[,2]) # Show the different phyla
table(is.na(taxa.print[,2])) # is there any NA phyla?
```




***********************
# 7. LAST PREPROCESSING
***********************

We will remove any sample with less than 500 reads from further analysis, and also any ASVs with unassigned phyla.

### 7.1. Create phyloseq object
The preprocessing will be easier to do with ASV, taxonomic and metadata tables combined in a phyloseq object.

```{r phyloseq-preprocess, echo=TRUE, eval=FALSE}
#_________________________
# Import metadata
metadata_table <- read.table(file.path(path.nagel, "00_Metadata-Nagel/Metadata-Nagel.csv"), header = TRUE, sep = ",")
colnames(metadata_table)

# Keep relevant data
sampledf <- metadata_table
rownames(sampledf) <- metadata_table$Run # have the same sample.names
sampledf$host_disease <- as.character(sampledf$host_disease)
sampledf[sampledf[, 'host_disease'] == "healthy", 'host_disease'] <- 'Healthy'

# Add host_subtype
sampledf[sampledf[, 'host_disease'] == "Healthy", 'host_subtype'] <- "HC"
sampledf[sampledf[, 'host_disease'] == "IBS", 'host_subtype'] <- "IBS-D"

sampledf$sample_type <- "stool"
sampledf$author <- "Nagel"
sampledf$sequencing_tech <- "Ion Torrent"
sampledf$variable_region <- "V4"
sampledf$Collection <- "1st" # only 1 collection time point per individual


#_________________________
# Create phyloseq object
physeq <- phyloseq(otu_table(seqtable.nochim, taxa_are_rows=FALSE), # by default, in otu_table the sequence variants are in rows
                  sample_data(sampledf), 
                  tax_table(taxa))

# Remove taxa that are eukaryota, or have unassigned Phyla
physeq <- subset_taxa(physeq, Kingdom != "Eukaryota")
physeq <- subset_taxa(physeq, !is.na(Phylum))
# Remove samples with less than 500 reads
physeq <- prune_samples(sample_sums(physeq)>=500, physeq)
# No sample was deleted, so we don't need to remove taxa present in low-count samples
# physeq <- prune_taxa(taxa_sums(physeq)>0, physeq)
```


### 7.2. Quick peek at data analysis
```{r plot, fig.width = 10, fig.height = 4}
# Absolute abundance
plot_bar(physeq, fill = "Phylum")+ facet_wrap("host_disease", scales="free_x") + theme(axis.text.x = element_blank())

# Relative abundance for Phylum
phylum.table <- physeq %>%
  tax_glom(taxrank = "Phylum") %>%                     # agglomerate at phylum level
  transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
  psmelt()                                             # Melt to long format

ggplot(phylum.table, aes(x = Sample, y = Abundance, fill = Phylum))+
  facet_wrap(~ host_disease, scales = "free") + # scales = "free" removes empty lines
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(size = 5, angle = -90))+
  labs(x = "Samples", y = "Relative abundance")
```


### 7.3. Save to disk
```{r save, eval=FALSE}
# Save to disk
saveRDS(raw_stats,   file.path(path.data, "01_Dada2-Nagel/raw_stats.rds"))
saveRDS(out1,        file.path(path.data, "01_Dada2-Nagel/out1.rds"))
saveRDS(out2,        file.path(path.data, "01_Dada2-Nagel/out2.rds"))
saveRDS(err,         file.path(path.data, "01_Dada2-Nagel/errorRates.rds"))
saveRDS(err_new,     file.path(path.data, "01_Dada2-Nagel/errorRates_modif.rds"))
saveRDS(seq_infered, file.path(path.data, "01_Dada2-Nagel/seq_infered.rds"))

# Taxa & Phyloseq object
saveRDS(taxa, file.path(path.data, "01_Dada2-Nagel/taxa_nagel.rds"))
saveRDS(physeq, file.path(path.root, "data/preprocessing/analysis-individual/CLUSTER/PhyloTree/input/physeq_nagel.rds"))
```




******************
# 8. SESSION INFO
******************

```{r session-info}
sessionInfo()
```
